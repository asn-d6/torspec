

                 Next-Generation Hidden Services in Tor
                         (DRAFT SPECIFICATION)
                          Draft 0, 2013-10-25


-1. Draft notes

   This document describes a proposed design and specification for
   hidden services in Tor version 0.2.5.x or later.  It's a replacement
   for the current rend-spec.txt, rewritten for clarity and for improved
   design.

   Look for the string "TODO" below: it describes gaps or uncertainties
   in the design.

   Change history:

0. Hidden services: overview and preliminaries.

   Hidden services aim to provide responder anonymity for bidirectional
   stream-based communication on the Tor network.  Unlike regular Tor
   connections, where the connection initiator receives anonymity but
   the responder does not, hidden services attempt to provide
   bidirectional anonymity.

   Other features include:

     * XXXX WRITEME

   Participants:

      Operator -- A person running a hidden service

      Host, "Server" -- The software run by the operator to provide a
         hidden service

      User -- A person contacting a hidden service.

      Client -- The Tor software running on the User's computer

      Hidden Service Directory (HSDir) -- A Tor node that hosts signed
        statements from hidden service hosts so that users can make
        contact with them.

      Introduction Point -- A Tor node that accepts connection requests
        for hidden services, and anonymously relays those requests to
        the hidden service.

      Rendezvous Point -- A Tor node to which clients and servers
        connect, which relays traffic between them.



0.1. Improvements over previous versions.

    XXXX writeme

0.2. Notation and vocabulary

   We write sequences of bytes in two ways:

     1. A sequence of two-digit hexadecimal values in square brackets,
        as in [AB AD 1D EA].

     2. A string of characters enclosed in quotes, as in "Hello". These
        characters in these string are encoded in their ascii
        representations; strings are NOT nul-terminated unless
        explicitly described as NUL terminated.

   We use the words "byte" and "octet" interchangeably.

   We use the vertical bar | to denote concatenation.

0.3. Cryptographic building blocks

   This specification uses the following cryptographic building blocks:

      * A stream cipher S(iv, k) where iv is a nonce of length S_IV_LEN
        bytes and k is a key of length S_KEY_LEN bytes.

      * A public key signature system SIGN_KEYGEN()->seckey, pubkey;
        SIGN_SIGN(seckey,msg)->sig; and SIGN_CHECK(sig, msg) -> { "OK",
        "BAD" }; where secret keys are of length SIGN_SECKEY_LEN bytes,
        public keys are of length SIGN_PUBKEY_LEN bytes, and signatures
        are of length SIGN_SIG_LEN bytes.

        This signature system must also support key blinding operations
        SIGN_BLIND_SECKEY(seckey, blind)->seckey2 and
        SIGN_BLIND_PUBKEY(pubkey, blind)->pubkey2 that meet the
        requirements discussed in appendix [KEYBLIND].

      * A public key agreement system "PK", providing
        PK_KEYGEN()->seckey, pubkey; PK_VALID(pubkey) -> {"OK", "BAD"};
        and PK_HANDHAKE(seckey, pubkey)->output; where secret keys are
        of length PK_SECKEY_LEN bytes, public keys are of length
        PK_PUBKEY_LEN bytes, and the handshake produces outputs of length
        PK_OUTPUT_LEN bytes.

      * A cryptographic hash function H(d), which should be preimage and
        collision resistant. It produces hashes of length HASH_LEN bytes.

      * A cryptographic message authentication code MAC(key,msg) that
        produces outputs of length MAC_LEN bytes.

      * A key derivation function KDF(input, personalization, n) that
        outputs n bytes.

   As a first pass, I suggest:

      * Instantiate S with AES128-CTR. [TODO: or ChaCha20?]

      * Instantiate SIGN with Ed25519 and the blinding protocol in
        [KEYBLIND].

      * Instantiate PK with Curve25519.

      * Instantiate H with SHA256. [TODO: really?]

      * Instantiate MAC with HMAC using H.

      * Instantiate KDF with HKDF using H.

   For legacy purposes, we specify compatibility with older versions of
   the Tor introduction point and rendezvous point protocols.  These
   used RSA1024, DH1024, AES128, and SHA1, as discussed in
   rend-spec.txt.

0.4. Protocol building blocks

   In sections below, we need to transmit the locations and identities
   of Tor nodes.  We do so in the format used by EXTEND2 cells in the
   Tor protocol:
         NSPEC      (Number of link specifiers)   [1 byte]
         NSPEC times:
           LSTYPE (Link specifier type)           [1 byte]
           LSLEN  (Link specifier length)         [1 byte]
           LSPEC  (Link specifier)                [LSLEN bytes]

   Link specifier types are as described in tor-spec.txt.  Every set of
   link specifiers MUST include at minimum specifiers of type [00]
   (TLS-over-TCP, IPv4) and [02] (legacy node identity).

   We also incorporate Tor's circuit extension handshakes, as used in
   CREATE2 and CREATED2 cells describe in tor-spec.txt.  In these
   handshakes, a client who knows a public key for a server sends a
   message, and receives a message from that server.  Once the exchange
   is done, the two parties have a shared set of forward-secure key
   material, and the client knows that nobody else shares that key
   material unless they control the secret key corresponding to the
   server's public key.

0.5. Acknowledgments

   XXXX reformat

   This design includes ideas from many people, including
     Christopher Baines,
     Daniel J. Bernstein,
     George Kadianakis,
     Tanja Lange,
     Robert Ransom,
     Ian Goldberg,
     Aniket Kate

   It's based on Tor's original hidden service design by Roger
   Dingledine, Nick Mathewson, and Paul Syverson, and on improvements to
   that design over the years by people including
     Karsten Loesing,
     Robert Ransom,
     Tobias Kamm,
     Thomas Lauterbach,
     Ferdinand Rieger,
     Christoph Weingarten,
     Christian Wilms
     Alessandro Preite Martinez

   We wouldn't be able to do any of this work without good attack
   designs from researchers including
     Alex Biryukov,
     Ivan Pustogarov,
     Ralf-Philipp Weinmann,
     Lasse Ã˜verlier,
     Paul Syverson.

   Several of these ideas have come from conversations with
      Christian Grothoff,
      Brian Warner,
      Zooko Wilcox-O'Hearn,

   Please forgive me if I've missed you; please forgive me if I've
   misunderstood your best ideas here too.


1. Protocol overview

   In this section, we outline the hidden service protocol.  This
   section omits some details in the name of simplicity; those are given
   more fully below, when we specify the protocol in more detail.

1.1. View from 10,000 feet

   A hidden service host prepares to offer a hidden service by choosing
   several Tor nodes to serve as its introduction points.  It builds
   circuits to those nodes, and tells them to forward introduction
   requests to it using those circuits.

   Once introduction points have been picked, the host builds a set of
   documents called "hidden service descriptors" (or just "descriptors"
   for short) and uploads them to a set of HSDir nodes.  These documents
   list the hidden service's current introduction points, and describe
   how to make contact with the hidden service.

   When a client wants to connect to a hidden service, it first chooses
   a Tor node at random to be its "rendezvous point", and builds a
   circuit to that rendezvous point.  If the does not have an up-to-date
   descriptor for the service, it contacts an appropriate HSDir and
   requests such a descriptor.

   The client then builds an anonymous circuit to one of the hidden
   service's introduction points listed in its descriptor, and gives the
   introduction point an introduction request to pass to the hidden
   service.  This introduction request includes the target rendezvous
   point, and the first part of a cryptographic handshake.

   Upon receiving the introduction request, the hidden service host
   makes an anonymous circuit to the rendezvous point, and completes the
   cryptographic handshake.  The rendezvous point connects the two
   circuits, and the cryptographic handshake gives the two parties a
   shared key, and prove to the client that it is indeed talking to the
   hidden service.

   Once the two circuits are joined, the client can send Tor RELAY cells
   to the server.  RELAY_BEGIN cells open streams to an external process
   or processes configured by the server; RELAY_DATA cells are used to
   communicate data on those streams, and so forth.

1.2. In more detail: naming hidden services

   Hidden services are named based on a long term public "identity key".
   This key is used to generate a special "onion address" usable by the
   Tor software. A public identity key K corresponds to the onion
   address "Enc(K).onion", where Enc is a base-32 encoding of K.

   Client software recognizes these addresses, extracts the keys, and
   and uses those to locate and authenticate hidden services.

   These keys are not used for direct signing operations.  See sections
   [IMD:AC] and [IMD:DIST] below.

1.3. In more detail: Access control [IMD:AC]

   Access control for a hidden service is imposed at multiple points
   through the process above.

   In order to download a descriptor, clients must know which blinded
   signing key used to sign it. (See the next section for more info on
   key blinding.)  This blinded signing key is derived from the
   service's public key, and, optionally, an additional secret that is
   not part of the hidden service's onion address.  The public key and
   this secret together constitute the service's "credential".

   To learn the introduction points, the clients must decrypt the body
   of the hidden service descriptor.  The encryption key for these is
   also derived from the service's credential.

   In order to make an introduction point send a request to the server,
   the client must know the introduction point, and know the service's
   per-introduction point authentication key in the hidden service
   descriptor.

   The final level of access control happens at the server itself, which
   may decide to respond or not respond to the client's request
   depending on the contents of the request.  The protocol is extensible
   at this point: at a minimum, the server requires that the client
   demonstrate knowledge the contents of the encrypted portion of the
   hidden service descriptor. The service may additionally require a
   user- or group-specific access token before it responds to requests.

1.4. In more detail: Distributing hidden service descriptors. [IMD:DIST]

   Periodically, hidden service descriptors become stored at different
   location, to prevent a single directory or small set of directories
   from becoming a good DoS target for removing a hidden service.

   For each period, the Tor directory authorities agree upon a
   collaboratively generated random value (See appendix [SHAREDRANDOM].)
   That value, combined with hidden service directories' public
   identity keys, determines their position in the hash ring for
   descriptors made in that period. [XXXX is this quite what I mean?]

   Each hidden service's descriptors placed into the ring in positions
   based on the key that was used to sign them.  Note that hidden
   service descriptors are not signed with the services' public keys
   directly.  Instead, we use a key-blinding system [KEYBLIND] to create
   a new key-of-the-day for each hidden service.  Any client that knows
   the hidden service's credential can derive these blinded signing keys
   for each given period, but without that credential it should be
   impossible to do so.

   The body of each descriptor is also encrypted with a key derived from
   the credential.

   To avoid a "thundering herd" problem where every service generates
   and uploads a new descriptor at the start of each period, each
   descriptor comes online at a time during the period that depends on
   its blinded signing key.  The keys for the last period remain valid
   until the new keys come online.

1.5. In more detail: Scaling to multiple hosts

   [THIS SECTION IS UNFINISHED]

   In order to allow multiple hosts to provide a single hidden service,
   I'm considering two options.

      * We can have each server build an introduction circuit to each
        introduction point, and have the introduction points responsible
        for round-robining between these circuits.  One service host is
        responsible for picking the introduction points and publishing
        the descriptors.

      * We can have servers choose their introduction points
        independently, and build circuits to them. One service host is
        responsible for combining these introduction points into a
        single descriptor.

   If we want to avoid having a single "master" host without which the
   whole service goes down (the "one service host" in the description
   above), we need a way to fail over from one host to another. We also
   need a way to coordinate between the hosts.  This is as yet
   undesigned.  Maybe it should use a hidden service?

   [TODO: Finalize this design.]

   [THIS SECTION IS UNFINISHED]

1.6. In more detail: Backward compatibility with older hidden service
      protocols

   This design is incompatible with the clients, server, and hsdir node
   protocols from older versions of the hidden service protocol as
   described in rend-spec.txt.  On the other hand, it is designed to
   enable the use of older Tor nodes as rendezvous points and
   introduction points.

1.7. In more detail: Offline operation

   In this design, a hidden service's secret identity key may be stored
   offline.  It's used only to generate blinded identity keys, which are
   used to sign descriptor signing keys.  In order to operate a hidden
   service, the operator can generate a number of descriptor signing
   keys and their certifications[SEE BELOW XXXXX], and their
   corresponding descriptor encryption keys, and export those to the
   hidden service hosts.

1.8. In more detail: A gallimaufry of keys

   Public/private keypairs defined in this document:

      Master (hidden service) identity key -- A master signing keypair used
        as the identity for a hidden service.  This key is not used on
        its own to sign anything; it is only used to generate blinded
        identity keys as described in [KEYBLIND] and [XXXX].

      Blinded identity key -- A keypair derived from the identity key,
        used to sign descriptor signing keys. Changes periodically for
        each service. Clients who know a 'credential' consisting of the
        service's public identity key and an optional secret can derive
        the public blinded identity key for a service.  This key is used
        as an index in the DHT-like structure of the directory system.

      Descriptor signing key -- A key used to sign hidden service
        descriptors.  This is signed by blinded identity keys. Unlike
        blinded identity keys and master identity keys, the secret part
        of this key must be stored online by hidden service hosts.

      Introduction point authentication key -- A short-term signing keypair
        used to identify a hidden service to given introduction point. A
        fresh keypair is made for each introduction point; these are used to
        sign the request that a hidden service host makes when establishing
        an introduction point, so that clients who know the public component
        of this key can get their introduction requests sent to the right
        service.

      Introduction point encryption key -- A short-term encryption keypair
        used when establishing connections via an introduction point. Plays a
        role analogous to Tor nodes' onion keys. A fresh keypair is made for
        each introduction point.

      Handshake key -- XXXX keep this?

   Symmetric keys defined in this document:

      Descriptor encryption keys -- A symmetric encryption key used to
        encrypt the body of hidden service descriptors. Derived from the
        current period and the hidden service credential.

   Public/private keypairs defined elsewhere:

      Onion key

      (Node) identity key

   Symmetric keys defined elsewhere:

      KH from circuit handshake [XXXXX expand]

2. Hidden service descriptors and how they are published

  XXXXX writeme

3. The introduction protocol

  XXXX writeme

4. The rendezvous prototocol

  XXXXX writeme


Appendix A. Signature scheme with key blinding [KEYBLIND]

  XXXX writeme


Appendix B. Producing a daily shared random value [SHAREDRANDOM]


NOTE TO SELF:
 circulate to asn, sysrqb, whomever else.
