

                 Next-Generation Hidden Services in Tor
                         (DRAFT SPECIFICATION)
                          Draft 0, 2013-10-31


-1. Draft notes

   This document describes a proposed design and specification for
   hidden services in Tor version 0.2.5.x or later.  It's a replacement
   for the current rend-spec.txt, rewritten for clarity and for improved
   design.

   Look for the string "TODO" below: it describes gaps or uncertainties
   in the design.

   Change history:

0. Hidden services: overview and preliminaries.

   Hidden services aim to provide responder anonymity for bidirectional
   stream-based communication on the Tor network.  Unlike regular Tor
   connections, where the connection initiator receives anonymity but
   the responder does not, hidden services attempt to provide
   bidirectional anonymity.

   Other features include:

     * XXXX WRITEME

   Participants:

      Operator -- A person running a hidden service

      Host, "Server" -- The software run by the operator to provide a
         hidden service

      User -- A person contacting a hidden service.

      Client -- The Tor software running on the User's computer

      Hidden Service Directory (HSDir) -- A Tor node that hosts signed
        statements from hidden service hosts so that users can make
        contact with them.

      Introduction Point -- A Tor node that accepts connection requests
        for hidden services, and anonymously relays those requests to
        the hidden service.

      Rendezvous Point -- A Tor node to which clients and servers
        connect, which relays traffic between them.



0.1. Improvements over previous versions.

    XXXX writeme

0.2. Notation and vocabulary

   Unless specified otherwise, all multi-octet integers are big-endian.

   We write sequences of bytes in two ways:

     1. A sequence of two-digit hexadecimal values in square brackets,
        as in [AB AD 1D EA].

     2. A string of characters enclosed in quotes, as in "Hello". These
        characters in these string are encoded in their ascii
        representations; strings are NOT nul-terminated unless
        explicitly described as NUL terminated.

   We use the words "byte" and "octet" interchangeably.

   We use the vertical bar | to denote concatenation.

0.3. Cryptographic building blocks

   This specification uses the following cryptographic building blocks:

      * A stream cipher S(iv, k) where iv is a nonce of length S_IV_LEN
        bytes and k is a key of length S_KEY_LEN bytes.

      * A public key signature system SIGN_KEYGEN()->seckey, pubkey;
        SIGN_SIGN(seckey,msg)->sig; and SIGN_CHECK(sig, msg) -> { "OK",
        "BAD" }; where secret keys are of length SIGN_SECKEY_LEN bytes,
        public keys are of length SIGN_PUBKEY_LEN bytes, and signatures
        are of length SIGN_SIG_LEN bytes.

        This signature system must also support key blinding operations
        SIGN_BLIND_SECKEY(seckey, blind)->seckey2 and
        SIGN_BLIND_PUBKEY(pubkey, blind)->pubkey2 that meet the
        requirements discussed in appendix [KEYBLIND].

      * A public key agreement system "PK", providing
        PK_KEYGEN()->seckey, pubkey; PK_VALID(pubkey) -> {"OK", "BAD"};
        and PK_HANDHAKE(seckey, pubkey)->output; where secret keys are
        of length PK_SECKEY_LEN bytes, public keys are of length
        PK_PUBKEY_LEN bytes, and the handshake produces outputs of length
        PK_OUTPUT_LEN bytes.

      * A cryptographic hash function H(d), which should be preimage and
        collision resistant. It produces hashes of length HASH_LEN bytes.

      * A cryptographic message authentication code MAC(key,msg) that
        produces outputs of length MAC_LEN bytes.

      * A key derivation function KDF(input, salt, personalization, n) that
        outputs n bytes.

   As a first pass, I suggest:

      * Instantiate S with AES128-CTR. [TODO: or ChaCha20?]

      * Instantiate SIGN with Ed25519 and the blinding protocol in
        [KEYBLIND].

      * Instantiate PK with Curve25519.

      * Instantiate H with SHA256. [TODO: really?]

      * Instantiate MAC with HMAC using H.

      * Instantiate KDF with HKDF using H.

   For legacy purposes, we specify compatibility with older versions of
   the Tor introduction point and rendezvous point protocols.  These
   used RSA1024, DH1024, AES128, and SHA1, as discussed in
   rend-spec.txt.  Except as noted, all RSA keys MUST have exponent
   values of 65537.

   As in [proposal 220], all signatures are generated not over
   strings themselves, but over those strings prefixed with a
   distinguishing value.


0.4. Protocol building blocks [BUILDING-BLOCKS]

   In sections below, we need to transmit the locations and identities
   of Tor nodes.  We do so in the link identification format used by
   EXTEND2 cells in the Tor protocol.
         NSPEC      (Number of link specifiers)   [1 byte]
         NSPEC times:
           LSTYPE (Link specifier type)           [1 byte]
           LSLEN  (Link specifier length)         [1 byte]
           LSPEC  (Link specifier)                [LSLEN bytes]

   Link specifier types are as described in tor-spec.txt.  Every set of
   link specifiers MUST include at minimum specifiers of type [00]
   (TLS-over-TCP, IPv4) and [02] (legacy node identity).

   We also incorporate Tor's circuit extension handshakes, as used in
   CREATE2 and CREATED2 cells describe in tor-spec.txt.  In these
   handshakes, a client who knows a public key for a server sends a
   message, and receives a message from that server.  Once the exchange
   is done, the two parties have a shared set of forward-secure key
   material, and the client knows that nobody else shares that key
   material unless they control the secret key corresponding to the
   server's public key.

0.5. Assigned relay cell types

   These relay cell types are reserved for use in the hidden service
   protocol.

      32 -- RELAY_COMMAND_ESTABLISH_INTRO
      33 -- RELAY_COMMAND_ESTABLISH_RENDEZVOUS
      34 -- RELAY_COMMAND_INTRODUCE1
      35 -- RELAY_COMMAND_INTRODUCE2
      36 -- RELAY_COMMAND_RENDEZVOUS1
      37 -- RELAY_COMMAND_RENDEZVOUS2
      38 -- RELAY_COMMAND_INTRO_ESTABLISHED
      39 -- RELAY_COMMAND_RENDEZVOUS_ESTABLISHED
      40 -- RELAY_COMMAND_INTRODUCE_ACK

0.5. Acknowledgments

   XXXX reformat these once the lists are more complete.

   This design includes ideas from many people, including
     Christopher Baines,
     Daniel J. Bernstein,
     Matthew Finkel,
     Ian Goldberg,
     George Kadianakis,
     Aniket Kate,
     Tanja Lange,
     Robert Ransom,

   It's based on Tor's original hidden service design by Roger
   Dingledine, Nick Mathewson, and Paul Syverson, and on improvements to
   that design over the years by people including
     Tobias Kamm,
     Thomas Lauterbach,
     Karsten Loesing,
     Alessandro Preite Martinez,
     Robert Ransom,
     Ferdinand Rieger,
     Christoph Weingarten,
     Christian Wilms,

   We wouldn't be able to do any of this work without good attack
   designs from researchers including
     Alex Biryukov,
     Lasse Ã˜verlier,
     Ivan Pustogarov,
     Paul Syverson
     Ralf-Philipp Weinmann,

   Several of these ideas have come from conversations with
      Christian Grothoff,
      Brian Warner,
      Zooko Wilcox-O'Hearn,

   Please forgive me if I've missed you; please forgive me if I've
   misunderstood your best ideas here too.


1. Protocol overview

   In this section, we outline the hidden service protocol.  This
   section omits some details in the name of simplicity; those are given
   more fully below, when we specify the protocol in more detail.

1.1. View from 10,000 feet

   A hidden service host prepares to offer a hidden service by choosing
   several Tor nodes to serve as its introduction points.  It builds
   circuits to those nodes, and tells them to forward introduction
   requests to it using those circuits.

   Once introduction points have been picked, the host builds a set of
   documents called "hidden service descriptors" (or just "descriptors"
   for short) and uploads them to a set of HSDir nodes.  These documents
   list the hidden service's current introduction points, and describe
   how to make contact with the hidden service.

   When a client wants to connect to a hidden service, it first chooses
   a Tor node at random to be its "rendezvous point", and builds a
   circuit to that rendezvous point.  If the does not have an up-to-date
   descriptor for the service, it contacts an appropriate HSDir and
   requests such a descriptor.

   The client then builds an anonymous circuit to one of the hidden
   service's introduction points listed in its descriptor, and gives the
   introduction point an introduction request to pass to the hidden
   service.  This introduction request includes the target rendezvous
   point, and the first part of a cryptographic handshake.

   Upon receiving the introduction request, the hidden service host
   makes an anonymous circuit to the rendezvous point, and completes the
   cryptographic handshake.  The rendezvous point connects the two
   circuits, and the cryptographic handshake gives the two parties a
   shared key, and prove to the client that it is indeed talking to the
   hidden service.

   Once the two circuits are joined, the client can send Tor RELAY cells
   to the server.  RELAY_BEGIN cells open streams to an external process
   or processes configured by the server; RELAY_DATA cells are used to
   communicate data on those streams, and so forth.

1.2. In more detail: naming hidden services

   Hidden services are named based on a long term public "identity key".
   This key is used to generate a special "onion address" usable by the
   Tor software. A public identity key K corresponds to the onion
   address "Enc(K).onion", where Enc is a base-32 encoding of K.

   Client software recognizes these addresses, extracts the keys, and
   and uses those to locate and authenticate hidden services.

   These keys are not used for direct signing operations.  See sections
   [IMD:AC] and [IMD:DIST] below.

1.3. In more detail: Access control [IMD:AC]

   Access control for a hidden service is imposed at multiple points
   through the process above.

   In order to download a descriptor, clients must know which blinded
   signing key used to sign it. (See the next section for more info on
   key blinding.)  This blinded signing key is derived from the
   service's public key, and, optionally, an additional secret that is
   not part of the hidden service's onion address.  The public key and
   this secret together constitute the service's "credential".

   To learn the introduction points, the clients must decrypt the body
   of the hidden service descriptor.  The encryption key for these is
   also derived from the service's credential.

   In order to make an introduction point send a request to the server,
   the client must know the introduction point, and know the service's
   per-introduction point authentication key in the hidden service
   descriptor.

   The final level of access control happens at the server itself, which
   may decide to respond or not respond to the client's request
   depending on the contents of the request.  The protocol is extensible
   at this point: at a minimum, the server requires that the client
   demonstrate knowledge the contents of the encrypted portion of the
   hidden service descriptor. The service may additionally require a
   user- or group-specific access token before it responds to requests.

1.4. In more detail: Distributing hidden service descriptors. [IMD:DIST]

   Periodically, hidden service descriptors become stored at different
   location, to prevent a single directory or small set of directories
   from becoming a good DoS target for removing a hidden service.

   For each period, the Tor directory authorities agree upon a
   collaboratively generated random value (See appendix [SHAREDRANDOM].)
   That value, combined with hidden service directories' public
   identity keys, determines their position in the hash ring for
   descriptors made in that period. [XXXX is this quite what I mean?]

   Each hidden service's descriptors placed into the ring in positions
   based on the key that was used to sign them.  Note that hidden
   service descriptors are not signed with the services' public keys
   directly.  Instead, we use a key-blinding system [KEYBLIND] to create
   a new key-of-the-day for each hidden service.  Any client that knows
   the hidden service's credential can derive these blinded signing keys
   for each given period, but without that credential it should be
   impossible to do so.

   The body of each descriptor is also encrypted with a key derived from
   the credential.

   To avoid a "thundering herd" problem where every service generates
   and uploads a new descriptor at the start of each period, each
   descriptor comes online at a time during the period that depends on
   its blinded signing key.  The keys for the last period remain valid
   until the new keys come online.

1.5. In more detail: Scaling to multiple hosts

   [THIS SECTION IS UNFINISHED]

   In order to allow multiple hosts to provide a single hidden service,
   I'm considering two options.

      * We can have each server build an introduction circuit to each
        introduction point, and have the introduction points responsible
        for round-robining between these circuits.  One service host is
        responsible for picking the introduction points and publishing
        the descriptors.

      * We can have servers choose their introduction points
        independently, and build circuits to them. One service host is
        responsible for combining these introduction points into a
        single descriptor.

   If we want to avoid having a single "master" host without which the
   whole service goes down (the "one service host" in the description
   above), we need a way to fail over from one host to another. We also
   need a way to coordinate between the hosts.  This is as yet
   undesigned.  Maybe it should use a hidden service?

   [TODO: Finalize this design.]

   [THIS SECTION IS UNFINISHED]

1.6. In more detail: Backward compatibility with older hidden service
      protocols

   This design is incompatible with the clients, server, and hsdir node
   protocols from older versions of the hidden service protocol as
   described in rend-spec.txt.  On the other hand, it is designed to
   enable the use of older Tor nodes as rendezvous points and
   introduction points.

1.7. In more detail: Offline operation

   In this design, a hidden service's secret identity key may be stored
   offline.  It's used only to generate blinded identity keys, which are
   used to sign descriptor signing keys.  In order to operate a hidden
   service, the operator can generate a number of descriptor signing
   keys and their certifications[SEE BELOW XXXXX], and their
   corresponding descriptor encryption keys, and export those to the
   hidden service hosts.

1.8. In more detail: ENCRYPTION KEYS AND REPLAY RESISTANCE

   XXXXXXXXXXX WRITEME


1.9. In more detail: A gallimaufry of keys

   [In the text below, an "encryption keypair" is roughly "a keypair can
   do Diffie-Hellman with" and a "signing keypair" is roughly "a keypair
   you can do ECDSA with."]

   Public/private keypairs defined in this document:

      Master (hidden service) identity key -- A master signing keypair used
        as the identity for a hidden service.  This key is not used on
        its own to sign anything; it is only used to generate blinded
        identity keys as described in [KEYBLIND] and [XXXX].

      Blinded identity key -- A keypair derived from the identity key,
        used to sign descriptor signing keys. Changes periodically for
        each service. Clients who know a 'credential' consisting of the
        service's public identity key and an optional secret can derive
        the public blinded identity key for a service.  This key is used
        as an index in the DHT-like structure of the directory system.

      Descriptor signing key -- A key used to sign hidden service
        descriptors.  This is signed by blinded identity keys. Unlike
        blinded identity keys and master identity keys, the secret part
        of this key must be stored online by hidden service hosts.

      Introduction point authentication key -- A short-term signing keypair
        used to identify a hidden service to given introduction point. A
        fresh keypair is made for each introduction point; these are used to
        sign the request that a hidden service host makes when establishing
        an introduction point, so that clients who know the public component
        of this key can get their introduction requests sent to the right
        service.  No keypair is ever used with more than one
        introduction point.

      Introduction point encryption key -- A short-term encryption keypair
        used when establishing connections via an introduction point. Plays a
        role analogous to Tor nodes' onion keys. A fresh keypair is made for
        each introduction point.

   Symmetric keys defined in this document:

      Descriptor encryption keys -- A symmetric encryption key used to
        encrypt the body of hidden service descriptors. Derived from the
        current period and the hidden service credential.

   Public/private keypairs defined elsewhere:

      Onion key -- Short-term encryption keypair

      (Node) identity key

   Symmetric key-like things defined elsewhere:

      KH from circuit handshake

2. Hidden service descriptors and how they are published [HSDIR]

   XXXXX writeme

   must list:
     - foreach intro point
       - how to contact it
       - authentication key ID to use, what kind it is.
       - encryption key to use, what kind it is.

     - which onion key formats can I use when extending to rendezvous points?

3. The introduction protocol

   The introduction protocol proceeds in three steps.

   First, a hidden service host builds an anonymous circuit to a
   Tor node and registers that circuit as an introduction point.

        [Between these steps, the hidden service publishes its
        introduction points and associated keys, and the client
        fetches them as described in section [HSDIR] above.]

   Second, a client builds an anonymous circuit to the introduction
   point, and sends an introduction request.

   Third, the introduction point relays the introduction request
   along the introduction circuit to the hidden service host, and
   acknowledges the introduction request to the client.

3.1. Registering an introduction point

3.1.1. Extensible ESTABLISH_INTRO protocol. [EST_INTRO]

   When a hidden service is establishing a new introduction point,
   it sends a ESTABLISH_INTRO cell with the following contents:

     SERVICE_KEY_TYPE [1 byte]
     SERVICE_KEY_LEN  [1 byte]
     SERVICE_KEY      [SERVICE_KEY_LEN bytes]
     FLAGS            [4 bytes]
     Any number of times:
        EXT_FIELD_TYPE [1 byte]
        EXT_FIELD_LEN  [1 byte]
        EXT_FIELD      [EXTRA_FIELD_LEN bytes]
     ZERO             [1 byte]
     HANDSHAKE_AUTH   [MAC_LEN bytes]
     SIGLEN           [1 byte]
     SIG              [SIGLEN bytes]

   The SERVICE_KEY_TYPE field indicates the type of the introduction
   point service key and the type of the MAC to use in for
   HANDSHAKE_AUTH. Recognized types are:
       [00, 01] -- Reserved for legacy introduction cells; see
                   [LEGACY_EST_INTRO below]
       [02] -- Ed25519; HMAC-SHA256.
       [FF] -- Reserved for maintenance messages on existing
               circuits; see MAINT_INTRO below.

   The SERVER_KEY_LEN field determines the length of the SERVICE_KEY
   field.  The SERVICE_KEY field contains the public introduction
   point authentication key.

   The FLAGS field contains the following (big-endian) flags.
   Unrecognized flags MUST be ignored.

      [XXXXX Define some flags or remove this field.]

   The EXT_FIELD_TYPE, EXT_FIELD_LEN, EXT_FIELD entries are reserved
   for future extensions to the introduction protocol. Extensions
   with unrecognized EXT_FIELD_TYPE values must be ignored.

   The ZERO field contains the byte zero; it marks the end of the
   extension fields.

   The HANDSHAKE_AUTH field contains the MAC of all earlier fields in
   the cell using as its key the shared per-circuit material ("KH")
   generated during the circuit extension protocol; see tor-spec.txt
   section 5.2, "Setting circuit keys".  It prevents replays of
   ESTABLISH_INTRO cells.

   SIGLEN is the length of the signature.

   SIG is a signature, using SERVER_KEY, of all contents of the cell,
   up to but not including SIG.  These contents are prefixed with the
   string "Tor establish-intro cell v1".

   Upon receiving an ESTABLISH_INTRO cell, a Tor node first decodes
   the key and the signature, and checks the signature.  The node
   must reject the ESTABLISH_INTRO cell and destroy the circuit in
   these cases:
        * If the key type is unrecognized
        * If the key is ill-formatted
        * If the signature is incorrect
        * If the HANDSHAKE_AUTH value is incorrect

        * If the circuit is already a rendezvous circuit.
        * If the circuit is already an introduction circuit.
        * If the key is already in use by another circuit.

   Otherwise, the node must associate the key with the circuit, for
   use later in INTRODUCE1 cells.

   [TODO: The above will work fine with, but it will do quite badly
   if we ever freak out and want to go back to RSA2048 or bigger.  Do
   we care?]

3.1.2. Registering an introduction point on a legacy Tor node [LEGACY_EST_INTRO]

   Tor nodes should also support an older version of the
   ESTABLISH_INTRO cell, first documented in rend-spec.txt.  New
   hidden service hosts must use this format when establishing
   introduction points at older Tor nodes that do not support the
   format above in [EST_INTRO].

   In this older protocol, an ESTABLISH_INTRO cell contains:

        KEY_LENGTH     [2 bytes]
        KEY            [KEY_LENGTH bytes]
        HANDSHAKE_AUTH [20 bytes]
        SIG            [variable, up to end of relay payload]

   The KEY_LENGTH variable determines the length of the KEY field.

   The KEY field is a ASN1-encoded RSA public key.

   The HANDSHAKE_AUTH field contains the SHA1 digest of (KH | "INTRODUCE").

   The SIG field contains an RSA signature, using PKCS1 padding, of
   all earlier fields.

   Note that since the relay payload itself may be no more than 498
   bytes long, the KEY_LENGTH field can never had a first byte other
   than [00] or [01].  These values are used to distinguish legacy
   ESTABLISH_INTRO cells from newer ones.

   Older versions of Tor always use a 1024-bit RSA key for these
   introduction authentication keys.

   Newer hidden services MAY use RSA keys up 1904 bits.  Any more
   than that will not fit in a RELAY cell payload.

3.1.3. Managing introduction circuits

   If the first byte of an ESTABLISH_INTRO cell is [ff], the cell's
   body contains an administrative command for the circuit.  The
   format of such a command is:

     Any number of times:
       SUBCOMMAND_TYPE [2 bytes]
       SUBCOMMAND_LEN  [2 bytes]
       SUBCOMMAND      [COMMAND_LEN bytes]

   Recognized SUBCOMMAND_TYPE values are:

       [00 01] -- update encryption keys

   Unrecognized SUBCOMMAND_TYPE values should be ignored.

3.1.3.1. Updating encryption keys (subcommand 0001) [UPDATE-KEYS-SUBCMD]

   Hidden service hosts send this subcommand to update the configured
   public encryption keys associated with this circuit. These keys
   are given in the form:
      NUMKEYS         [1 byte]
      NUMKEYS times:
        KEYTYPE         [1 byte]
        KEYLEN          [1 byte]
        KEY             [KEYLEN bytes]
      TIMESTAMP       [4 bytes]
      SIGLEN          [1 byte]
      SIGNATURE       [SIGLEN bytes.]

   The KEYTPE value [01] is for Curve25519 keys.

   The TIMESTAMP field is a monotonically increasing value across a
   given introduction point authentication key, but need not correspond
   correspond to actual time.  A counter is recommended.

   The SIGNATURE must be generated with the introduction point
   authentication key, and must cover all the entire subcommand body,
   prefixed with the string "Tor hidden service introduction
   encryption keys v1".

   [TODO: Nothing is done here to prove ownership of the encryption
   keys. Does that matter?]

   [TODO: The point here is to allow encryption keys to change while
   maintaining an introduction point and not forcing a client to download
   a new descriptor.  I'm not sure if that's worth it.  It makes clients
   who have seen a key before distinguishable from ones who have not.]

   Setting the encryption keys for a given circuit replaces the
   previous keys for that circuit.

3.2. Sending an INTRODUCE1 cell to the introduction point.

   In order to participate in the introduction protocol, a client
   must know the following:

     * An introduction point for a service.
     * The introduction authentication key for that introduction point.
     * The introduction encryption key for that introduction point.

   The client sends an INTRODUCE1 cell to the introduction point,
   containing an identifier for the service, an identifier for the
   encryption key that the client intends to use, and an opaque blob
   to be relayed to the hidden service host.

   In reply, the introduction point sends an INTRODUCE_ACK cell back
   to the client, either informing it that its request has been
   delivered, or that its request will not succeed.

3.2.1. INTRODUCE1 cell format

   An INTRODUCE1 cell has the following contents:

     AUTH_KEYID      [32 bytes]
     ENC_KEYID       [8 bytes]
     Any number of times:
       EXT_FIELD_TYPE [1 byte]
       EXT_FIELD_LEN  [1 byte]
       EXT_FIELD      [EXTRA_FIELD_LEN bytes]
     ZERO             [1 byte]
     ENCRYPTED        [Up to end of relay payload]

   (XXXX Add a field to determine the type of ENCRYPTED?)

   Upon receiving an INTRODUCE1 cell, the introduction point checks
   whether AUTH_KEYID and ENC_KEYID match a configured introduction
   point authentication key and introduction point encryption key.
   If they do, the cell is relayed; if not, it is not.

   The AUTH_KEYID for an Ed25519 public key is the public key itself.
   The ENC_KEYID for a Curve25519 public key is the first 8 bytes of
   the public key.  (This key ID is safe to truncate, since all the
   keys are generated by the hidden service host, and the ID is only
   valid relative to a single AUTH_KEYID.)  The ENCRYPTED field is as
   described in 3.3 below.

   To relay an INTRODUCE1 cell, the introduction point sends an
   INTRODUCE2 cell with exactly the same contents.

3.2.2. INTRODUCE_ACK cell format.

   An INTRODUCE_ACK cell has the following fields:
     STATUS    [2 bytes]
     Any number of times:
       EXT_FIELD_TYPE [1 byte]
       EXT_FIELD_LEN  [1 byte]
       EXT_FIELD      [EXTRA_FIELD_LEN bytes]

   Recognized status values are:
     [00 00] -- Success: cell relayed to hidden service host.
     [00 01] -- Failure: service ID not recognzied
     [00 02] -- Failure: key ID not recognized
     [00 03] -- Bad message format

   The extension field type 0001 is a signed set of encryption keys;
   its body matches the body of the key update command in
   [UPDATE-KEYS-CMD].  Whenever sending status [00 02], the
   introduction point MUST send this extension field.

3.2.3. Legacy formats

   When the ESTABLISH_INTRO cell format of [LEGACY_EST_INTRO] is
   used, INTRODUCE1 cells are of the form:

     AUTH_KEYID_HASH  [20 bytes]
     ENC_KEYID        [8 bytes]
     Any number of times:
       EXT_FIELD_TYPE [1 byte]
       EXT_FIELD_LEN  [1 byte]
       EXT_FIELD      [EXTRA_FIELD_LEN bytes]
     ZERO             [1 byte]
     ENCRYPTED        [Up to end of relay payload]

   Here, AUTH_KEYID_HASH is the hash of the service key used to
   establish the introduction.

   Because of limitations in older versions of Tor, the relay payload
   size for these INTRODUCE1 cells must always be at least 246 bytes,
   or they will be rejected as invalid.

3.3. Processing an INTRODUCE2 cell at the hidden service.

   Upon receiving an INTRODUCE2 cell, the hidden service host checks
   whether the AUTH_KEYID/AUTH_KEYID_HASH field and the ENC_KEYID
   fields are as expected, and match the configured authentication and
   encryption key(s) on that circuit.

   The service host then checks whether it has received a cell with
   these contents before.  If it has, it silently drops it as a
   replay. (It must maintain a replay cache for as long as it accepts
   cells with the same encryption key.)

   If the cell is not a replay, it decrypts the ENCRYPTED field,
   establishes a shared key with the client, and authenticates the whole
   contents of the cell as having been unmodified since they left the
   client. There may be multiple ways of decryption the ENCRYTPED field,
   depending on the chosen type of the encryption key.  Requirements for
   an introduction handshake protocol are described in
   [INTRO-HANDSHAKE-REQS]. We specify one below in section
   [NTOR-WITH-EXTRA-DATA].

   The decrypted plaintext must have the form:

      REND_TOKEN                                 [20 bytes]
      Any number of times:
          EXT_FIELD_TYPE                         [1 byte]
          EXT_FIELD_LEN                          [1 byte]
          EXT_FIELD                              [EXTRA_FIELD_LEN bytes]
      ZERO                                       [1 byte]
      ONION_KEY_TYPE                             [2 bytes]
      ONION_KEY                                  [depends on ONION_KEY_TYPE]
      NSPEC      (Number of link specifiers)     [1 byte]
      NSPEC times:
          LSTYPE (Link specifier type)           [1 byte]
          LSLEN  (Link specifier length)         [1 byte]
          LSPEC  (Link specifier)                [LSLEN bytes]
      PAD        (optional padding)              [up to end of plaintext]


   Upon processing this plaintext, the hidden service makes sure that
   any required authentication is present in the extension fields, and
   then extends a rendezvous circuit to the node described in the LSPEC
   fields, using the ONION_KEY to complete the extension.  As mentioned
   in [BUILDING-BLOCKS], the "TLS-over-TCP, IPv4" and "Legacy node
   identity" specifiers must be present.

   The SHOULD NOT reject any LSTYPE fields which it doesn't
   recognize; instead, it should use them verbatim in its EXTEND
   request to the extend to the rendezvous point.

   The ONION_KEY_TYPE field is one of:

      [01] TAP-RSA-1024:  ONION_KEY is 128 bytes long.
      [02] NTOR:          ONION_KEY is 32 bytes long.

   The ONION_KEY field describes the onion key that must be used
   when extending to the rendezvous point.  It must be of a type
   listed as supported in the hidden service descriptor.

   Upon receiving a well-formed INTRODUCE2 cell, the hidden service host
   will have:
     * The information needed to connect to the client's chosen
       rendezvous point.
     * The second half of a handshake to authenticate and establish a
       shared key with the hidden service client.
     * A set of shared keys to use for end-to-end encryption.

3.3.1. Introduction handshake encryption requirements [INTRO-HANDSHAKE-REQS]

   When decoding the encrypted information in an INTRODUCE2 cell, a
   hidden service host must be able to:

     * Decrypt additional information included in the INTRODUCE2 cell,
       to include the rendezvous token and the information needed to
       extend to the rendezvous point.

     * Establish a set of shared keys for use with the client.

     * Authenticate that the cell has not been modified since the client
       generated it.

   Note that the old TAP-derived protocol of the previous hidden service
   design achieved the first two requirements, but not the third.

3.3.2. Example encryption handshake: ntor with extra data [NTOR-WITH-EXTRA-DATA]

   This is a variant of the ntor handshake (see tor-spec.txt, section
   5.1.4; see proposal 216; and see "Anonymity and one-way
   authentication in key-exchange protocols" by Goldberg, Stebila, and
   Ustaoglu).

   Notation here is as in section 5.1.4 of tor-spec.txt, which defines
   the ntor handshake.

   The PROTOID for this variant is "hidden-service-ntor-curve25519-sha256-1".
   Define the tweak value t_hsenc, and the tag value m_hsexpand as:
      t_hsenc    = PROTOID | ":hs_key_extract"
      m_hsexpand = PROTOID | ":hs_key_expand"

   To make an INTRODUCE cell, the client must know a public encryption
   key B for the hidden service on this introduction circuit.  The
   client generates a single-use keypair:
             x,X = KEYGEN()
   and computes:
             secret_hs_input = EXP(B,x) | AUTH_KEYID | X | B | PROTOID
             info = m_hsexpand | credential
             hs_keys = HKDF(secret_hs_input, t_hsenc, info,
                            S_KEY_LEN+MAC_LEN)
             ENC_KEY = hs_keys[0:S_KEY_LEN]
             MAC_KEY = hs_keys[S_KEY_LEN:S_KEY_LEN+MAC_KEY_LEN]

   (XXXX can't use credential here; use daily symmetric thing instead)

   and sends as the INTRODUCE1 cell body:

            AUTH_KEYID/AUTH_KEYID_HASH  [20 or 32 bytes]
            ENC_KEYID                   [8 bytes]
            ENCRYPTED:
               CLIENT_PK                [G_LENGTH bytes]
               ENCRYPTED_DATA           [Padded to length of plaintext]
               MAC                      [MAC_LEN bytes]

   Here, the encryption key plays the role of B in the regular ntor
   handshake, and the AUTH_KEYID field plays the role of the node ID.
   The CLIENT_PK field is the public key X.  The ENCRYPTED_DATA field is
   the message plaintext, encrypted with the symmetric key ENC_KEY.  The
   MAC field is a MAC of all of the cell from the AUTH_KEYID through the
   end of ENCRYPTED_DATA, using the MAC_KEY value as its key.

   [TODO: should we have a cheap proof of knowledge of the credential
   before we do the public key operation?]

   To process this format, the hidden service checks PK_VALID(CLIENT_PK)
   as necessary, and then computes ENC_KEY and MAC_KEY as the client did
   above, except using EXP(CLIENT_PK,b) in the calculation of
   secret_hs_input.  The service host then checks whether the MAC is
   correct.  If it is invalid, it drops the cell.  Otherwise, it
   computes the plaintext by decrypting ENCRYPTED_DATA.

   The hidden service host now completes the ntor handshake with the
   modified PROTOID as given above, and is ready to send SERVER_PK and
   AUTH to the client.  The keys generated by the handshake will be used
   to encrypt and authenticate data end-to-end between the client and
   the server.

   XXXX describe handshake data

   XXXX describe security issues; discuss


3.4. Authentication during the introduction phase.

   XXXX writeme

4. The rendezvous protocol

   Before connecting to a hidden service, the client first builds a
   circuit to an arbitrarily chosen Tor node, and sends an
   ESTABLISH_RENDEZVOUS cell.  The server later connects to the same
   server and sends a RENDEZVOUS cell.  Once this has occurred, the
   relay forwards the contents of the RENDEZVOUS cell to the client, and
   joins the two circuits together.

4.1. Establishing a rendezvous point

   Alice sends the rendezvous point an ESTABLISH_RENDEZVOUS containing a
   20-byte value.
            RENDEZVOUS_COOKIE         [20 bytes]

   Rendezvous points MUST ignore any extra bytes in an
   ESTABLISH_RENDEZVOUS message.  (Older versions of Tor did not.)

   The rendezvous cookie is an arbitrary 20-byte value, chosen randomly
   by the client. The client SHOULD choose a new rendezvous cookie for
   each new connection attempt. If the rendezvous cookie is already in
   use on an existing circuit, the rendezvous point should reject it and
   destroy the circuit.

   Upon receiving a RELAY_COMMAND_ESTABLISH_RENDEZVOUS cell, the
   rendezvous point the cookie with the circuit on which it was sent. It
   replies to Alice with an empty RELAY_COMMAND_RENDEZVOUS_ESTABLISHED
   cell to indicate success.

   The client MUST NOT use the circuit which sent the cell for any
   purpose other than rendezvous with the given location-hidden service.

   The client should establish a rendezvous point BEFORE trying to
   connect to a hidden service.

4.2. Joining to a rendezvous point

   To complete a rendezvous, the hidden service host connects to the
   rendezvous point and says:
       RENDEZVOUS_COOKIE          [20 bytes]
       HANDSHAKE_INFO             [variable; depends on handshake type
                                   used.]


  XXXXXX write more


4.3. Using legacy hosts as rendezvous points

   The behavior of ESTABLISH_RENDEZVOUS is unchanged from older versions
   of this protocol, except that relays should now ignore unexpected
   bytes at the end.

   Old versions of Tor required that RENDEZVOUS cell payloads be exactly
   168 bytes long.  XXXX write more


5. Encrypting data between client and host


   XXXXXX write me

Appendix A. Signature scheme with key blinding [KEYBLIND]

  We propose the following scheme for key blinding, based on Ed25519.

  Let the basepoint be written as B. Assume B has prime order l, so
  lB=0.  Let a master keypair be written as (a,A), where a is the
  private key and A is the public key (A=aB).

  To compute the daily key for a period p, compute the blinding factor h
  as H(credential, B, p).  Then let:
      private key for the period:   a' = h a
      public key for the period:    A' = h' A = (ha)B

  Generating a signature of M: given a deterministic random-looking r
  (see EdDSA paper), take R=rB, S=r+hash(R,A',M)ah mod l. Send signature
  (R,S) and public key A'.

  Verifying the signature: Check whether SB = R+hash(R,A',M)A'.

  (If the signature is valid,
       SB = (r + hash(R,A',M)ah)B
          = rB + (hash(R,A',M)ah)B
          = R + hash(R,A',M)A' )

  See https://trac.torproject.org/projects/tor/ticket/8106 for an
  extensive discussion of alternatives here.  I've transcribed this
  from a description by Tanja Lange at the end of the thread. TODO:
  We'll want a proof for this.

Appendix B. Producing a daily shared random value [SHAREDRANDOM]

  Here's a protocol for producing a shared random value.  It should
  run less frequently than the directory consensus algorithm.  It
  runs in these phases.

    1. COMMITMENT
    2. REVEAL
    3. COMPUTE SHARED RANDOM or GOTO 1.

  It should be implemented by software other than Tor, which should
  be okay for authorities.

  Note: This is not a great protocol. It has a number of failure
  modes. Better protocols seem hard to implement, though, and it
  ought to be possible to drop in a replacement here, if we do it
  right.

  At the start of phase 1, each participating authority publishes a
  statement of the form:

      shared-random 1
      shared-random-type commit
      signing-key-certification (certification here; see proposal 220)
      commitment-key-certification (certification here; see proposal 220)
      published YYYY-MM-DD HH:MM:SS
      period-start YYYY-MM-DD HH:MM:SS
      attempt INT
      commitment sha512 C
      signature (made with commitment key; see proposal 220)

  The signing key is the one used for consensus votes, signed by the
  directory authority identity key.  The commitment key is used for
  this protocol only.  The signature is made with the commitment
  key.  The period-start value is the start of the period for which
  the shared random value should be in use.  The attempt value
  starts at 1, and increments by 1 for each time that the protocol fails.

  The other fields should be self-explanatory.

  The commitment value C is a base64-encoded SHA-512 hash of a
  256-bit random value R.

  During the rest of phase 1, every authority collects the
  commitments from other authorities. (XXXX say more)


  At the start of phase 2, each participating authority publishes:
      shared-random 1
      shared-random-type reveal
      signing-key-certification (certification here; see proposal 220)
      commitment-key-certification (certification here; see proposal 220)
      received-commitment ID sig
      received-commitment ID sig
      published YYYY-MM-DD HH:MM:SS
      period-start YYYY-MM-DD HH:MM:SS
      attempt INT
      commitment sha512 C
      reveal R
      signature (made with commitment key; see proposal 220)

  The R value is the one used to generate C. The received-commitment
  lines are the signatures on the documents from other authorities
  in phase 1. All other fields are as in the commitments.

  During the rest of phase 2, every authority collects the
  reveals from other authorities. (XXXX say more)

  At the start of phase 3, each participating authority either has a
  reveal from every authority that it received a commitment from, or
  it does not.  If it does have such a reveal, it says:

      shared-random 1
      shared-random-type finish
      signing-key-certification (certification here; see proposal 220)
      commitment-key-certification (certification here; see proposal 220)
      received-commitment ID sig R
      received-commitment ID sig R ...
      published YYYY-MM-DD HH:MM:SS
      period-start YYYY-MM-DD HH:MM:SS
      attempt INT
      consensus C
      signature (made with commitment key; see proposal 220)

  Where C = SHA256(ID | R | ID | R | ID | R | ...) where the ID
  values appear in ascending order and the R values appear after
  their corresponding ID values.

  If phase 3 fails, and some authorities did not reveal, the
  authority says:

      shared-random 1
      shared-random-type fail
      signing-key-certification (certification here; see proposal 220)
      commitment-key-certification (certification here; see proposal 220)
      received-commitment ID sha512 C
      received-commitment ID sha512 C ...
      published YYYY-MM-DD HH:MM:SS
      period-start YYYY-MM-DD HH:MM:SS
      attempt INT
      did-not-reveal ID
      did-not-reveal ID ...
      signature (made with commitment key; see proposal 220)

  (XXXX describe how to start over)

  See https://trac.torproject.org/projects/tor/ticket/8244 for more
  discussion here.

  (TODO: should this be its own spec?  If so, does it have to use
  our regular metaformat or can it use something less sucky?)

Appendix C. Selecting nodes [PICKNODES]

  Picking introduction points
  Picking rendezvous points

