Working Title: prop259 redux


0.0. Preliminaries

   Nick wrote this; it isn't done yet.

   It is derived from the following, by Isis Lovecruft, George
   Kadianakis, and Ola Bini:

     https://raw.githubusercontent.com/twstrike/torspec/review/proposals/259-guard-selection.txt

   It is in part a restatement of it, in part a simplification, and in
   part a refactoring so that it does not have the serialization
   problems noted by George Kadianakis.  It makes other numerous small
   changes.

   This document attempts to describe the algorithm in terms of data
   flows.

   Whenever I say "Y is a subset of X" you can think in terms of
   "Y-membership is a flag that can be set on members of X" or
   "Y-membership is a predicate that can be evaluated on members of
   X."

   "More work is needed."  There's a to-do at the end of the document.


X.0.  The guards listed in the current consensus.

   By GUARDS we mean the set of all guards in the current consensus.

X.1.  The Sampled Guard Set.

   We maintain a set, SAMPLED_GUARDS, that persists across invocations
   of Tor. It is an unordered subset of the nodes that we have
   seen listed as a guard in the consensus at some point.  For each
   such guard, we record persistently:

      - ADDED_ON_DATE: The date on which it was added to
        sampled_guards
      - ADDED_BY_VERSION: The version of Tor that added it to
        sampled_guards
      - IS_LISTED: Whether it was listed as a usable Guard in the
        _most recent_ consensus we have seen.
      - FIRST_UNLISTED_AT: If IS_LISTED is false, the publication date
        of the earliest consensus in which this guard was listed such
        that we have not seen it listed in any later consensus.
        Otherwise "None."

   For each guard in SAMPLED_GUARDS, we also record this data,
   non-persistently:
      - A 'last tried to connect at' time.  Default 'never'.
      - A 'last successfully connected through' time. Default 'never'.
      - An "is reachable" tristate, with possible values { yes, no,
        maybe }.  Default 'maybe'.

        # ASN What's the point of 'yes'? Isn't 'yes' actually 'maybe'?
          A guard that worked at one second, can actually fail the next second.

   We require that SAMPLED_GUARDS contain at least MIN_SAMPLE_FRACTION
   [previously SAMPLE_SET_THRESHOLD] of the number of guards in the
   consensus, but not more than MAX_SAMPLE_FRACTION [previously
   MAXIMUM_SAMPLE_SIZE_THRESHOLD] of the number of guards in the
   consensus.

   To add a new guard to SAMPLED_GUARDS, pick an entry at random from
   GUARDS - SAMPLED_GUARDS, weighted by bandwidth.

   We remove an entry from SAMPLED_GUARDS if:

      * We have a live consensus, and IS_LISTED is false, and
        FIRST_UNLISTED_AT is over REMOVE_UNLISTED_GUARDS_AFTER
        [previously ENTRY_GUARD_REMOVE_AFTER] days in the past.
   OR
      * We have a live consensus, and we cannot parse
        ADDED_BY_VERSION, or ADDED_ON_DATE is over GUARD_LIFETIME ago.

   Note that SAMPLED_GUARDS does not depend on our configuration.  It
   is possible that we can't actually connect to any of these guards.


     **Rationale**

   The Sampled guard set is meant to limit the total number of guards
   that a client will connect to in a given period.  The upper limit
   on its size prevents us from considering too many guards.

   The first expiration mechanism prevents us from retaining members
   in SAMPLED_GUARDS that would fingerprint us. (????)

   # ASN ^ Not sure if this is true. Having !IS_LISTED guards in our guard list
     is not a fingerprint since we don't probe them. Maybe the rationale for
     the first expiration mechanism is to keep our guard list from constantly
     growing with useless nodes?

   The second expiration mechanism makes us rotate our guards slowly
   over time.


X.2. The Usable Sample

   We maintain another set, FILTERED_GUARDS, that does not persist. It
   is derived from:
       - SAMPLED_GUARDS
       - our current configuration,
       - the path bias information.

   A guard is a member of FILTERED_GUARDS if and only if all of the
   following are true: [previously IS_LIVE]

       - It is a member of SAMPLED_GUARDS, with IS_LISTED set to true.
       - It is not disabled because of path bias issues.
       - [XX bad_since???]
       - [XX usable descriptor??]
       - It is not disabled because of ReachableAddress policy [XX??]
       - It is not disabled because of ExcludeNodes.
       - It is a general-purpose router, not a bridge. [XX usebridges]

   We have an additional subset, USABLE_FILTERED_GUARDS, which is
   defined to be the subset of FILTERED_GUARDS where "is reachable" is
   "yes" or "maybe".

   We try to maintain a requirement that USABLE_FILTERED_GUARDS contain at
   least MIN_FILTERED_SAMPLE elements:

   Whenever we are going to sample from USABLE_FILTERED_GUARDS, and it
   contains fewer than MIN_FILTERED_SAMPLE elements, we add new
   elements to SAMPLED_GUARDS until one of the following is true:
     * USABLE_FILTERED_GUARDS is large enough,
   OR
     * SAMPLED_GUARDS is at its maximum size.

X.Used. The confirmed-guard list. [xx formerly USED_GUARDS]

  We maintain a persistent ordered list, CONFIRMED_GUARDS.  It contains
  guards that we have used before, in our preference order of using
  them.  It is a subset of SAMPLED_GUARDS.  For each guard in this
  list, we store persistently:
      - Its fingerprint

  For each guard on this list, we also store non-persistently:
      - A "pending" flag.

  We add new members to CONFIRMED_GUARDS when we mark a circuit built
  through one as "for user traffic."

  Whenever we remove a member from SAMPLED_GUARDS, we also remove it
  from CONFIRMED_GUARDS.

  # XXX I feel that 'USED_GUARDS' is a more accurate name than CONFIRMED_GUARDS, maybe.

X.3. The Primary guards

  We keep a run-time non-persistent ordered list of PRIMARY_GUARDS.
  It is a subset of FILTERED_SAMPLED_GUARDS.  It contains N_PRIMARY_GUARDS
  elements.

  To compute primary guards, take the intersection of CONFIRMED_GUARDS and
  FILTERED_SAMPLED_GUARDS, and take the first N_PRIMARY_GUARDS
  elements.  If there are fewer than N_PRIMARY_GUARDS elements, add
  additional elements to PRIMARY_GUARDS chosen _uniformly_ at random
  from (FILTERED_SAMPLED_GUARDS - CONFIRMED_GUARDS).

  Note that PRIMARY_GUARDS do not have to be in
  USABLE_FILTERED_SAMPLE_GUARDS: they might be unreachable.

  # ASN The FILTERED_SAMPLED_GUARDS identifier is not defined.
    Maybe that's FILTERED_GUARDS? Which one do we prefer?

X.4. Retrying guards.

  (We run this process as frequently as needed. It can be done once a
  second, or just-in-time.)

  If a primary sampled guard's "reachable" status is "no", and its 'last tried
  to connect at time' is greater than PRIMARY_GUARDS_RETRY_INTERVAL
  ago, we change its "reachable" status to "maybe".

  If a non-primary sampled guard's "reachable" status is "no" and its 'last
  tried to connect at time' is greater than GUARDS_RETRY_INTERVAL ago,
  we change its "reachable" status to "maybe".

X.5. Selecting guards for circuits.

  # ASN I feel that this proposal uses the same guard list input for all
    circuits regardless of the type of circuit. For this to work, we need to
    only consider guards that are Stable && Fast && V2Dir. Otherwise, a circuit
    that requires a V2Dir might receive a guard that is not V2Dir.

  Every origin circuit is now "usable on completion" or "usable after
  retry" or "waiting for retry" or "complete".  You may only attach
  streams to "complete" circuits.

  # ASN I like these circuit states! I think we should try to turn this into a
    more formal state machine. USABLE_ON_COMPLETION, USABLE_AFTER_RETRY, etc.
    Then maybe we should draw the state transitions.

  We keep, as transient state:
    * "last_time_on_internet" the last time at which we successfully
      used a circuit or connected to a guard.

  When we want to build a circuit, and we need to pick a guard:

    * If any entry in PRIMARY_GUARDS has "reachable" status of "maybe"
      or "yes", return one such guard _uniformly_ at random.  The
      circuit is "usable on completion".

      # ASN: I think we should return primary guards in order, and not uniformly at random.
        If the first primary guard actually works, we should ideally always pick that one.

      # ASN: What about 'pending' when examining primary guards?

    * Otherwise, if the intersection of USABLE_FILTERED_SAMPLED_GUARDS
      and CONFIRMED_GUARDS is nonempty, return the first entry in that
      intersection that is not "pending". Make it "pending".  The
      circuit is "usable after retry".  (If all entries are "pending",
      pick the first "pending" one.)

      # ASN Captain obvious, but the intersection should preserve the order of CONFIRMED_GUARDS here.

    * Otherwise, if there is no such entry, select a member at
      random from USABLE_FILTERED_SAMPLED_GUARDS. Make it "pending".
      The circuit is "usable after retry."

  We update the 'last tried to connect at' time for the guard to
  'now.'

X.6. When a circuit fails or succeeds.

   # ASN Maybe we can split this into two sections. One for succeed, one for fail.

   When a circuit fails in a way that makes us conclude that a guard
   is not reachable, we take the following steps:

      * We set its "reachable" status to "no".
      * If it was "pending", we make it non-pending.

      * If this was a primary guard, and all primary guards now have
        reachable status of "no", then mark all "usable after retry" circuits
        as "usable on completion"; and also mark all "waiting for retry"
        circuits as "complete". (You may attach streams to
        them.)

   # ASN Should we say here that after the circuit fails with this guard, we
     need to restart the guard picking algorithm for this circuit? Or is this
     handled by the layer above?

   When a circuit succeeds in a way that makes us conclude that a
   guard _was_ reachable, we take these steps:

      * We set its "reachable" status to "yes".
      * We set its "last successfully connected through" time to
        "now".
      * If the guard was "pending", we add it to the end of
        CONFIRMED_GUARDS. ASN and clear pending?

      * If this was a primary guard, then close all "waiting for
        retry" circuits and all "usable after retry" circuits.

        # ASN Should we also say "and restart the guard search for those
          circuits?". Or do we leave this to the Tor circuit retry layer?

        # ASN Do we update the state of the non-primary guards of the circuits
          that we just ditched?

      * If this circuit was "usable on completion", close all "usable
        after retry" circuits.  This circuit is now "complete". You
        may attach streams to this circuit.

        # ASN Hm. What is this rule about? Isn't the rule above also covering this one?
              See end of document for a state transition problem based on this rule.

      * If this circuit was "usable after retry", then check whether
        the "last_seen_internet" is more than
        INTERNET_LIKELY_DOWN_INTERVAL seconds ago:
           * If it is not, you may attach streams to this circuit. # ASN aka "mark it 'complete'"?

           * If it is, then mark all PRIMARY_GUARDS as "maybe" reachable.  You
             may not yet attach streams to this circuit. It is "waiting for
             retry".

             # ASN ^ Maybe we should mention that after we mark primary guards as
               retriable we need to restart the search?


X.7.  Whenever we get a new consensus.

   We update GUARDS.

   For every guard in SAMPLED_GUARDS, we update IS_LISTED and
   FIRST_UNLISTED_AT.

   [**] We remove entries from SAMPLED_GUARDS if appropriate,
   according to the sampled-guards expiration rules.  If they were in
   CONFIRMED_GUARDS, we also remove them from USED_GUARDS.

   We recompute FILTERED_GUARDS, and everything that derives from it.

   (Whenever one of the configuration options that affects the filter
   is updated, we repeat the process above, starting at the [**] line.)

A.1.  Parameters

   MIN_SAMPLE_FRACTION

   MAX_SAMPLE_FRACTION

   GUARD_LIFETIME

   REMOVE_UNLISTED_GUARDS_AFTER.

   MIN_FILTERED_SAMPLE

   N_PRIMARY_GUARDS

   PRIMARY_GUARDS_RETRY_INTERVAL

   GUARDS_RETRY_INTERVAL

   INTERNET_LIKELY_DOWN_INTERVAL


B.1. Still non-addressed issues

   Simulating actual behavior of the above.

   Formats to use when making information persistent

   Will this work in a dystopic world?

   UseBridges behavior

   EntryNodes behavior

   More rationales everywhere.

   Restore the nice motivation/etc sections from one of the old prop259s.


# ASN Here is a case where the state machine does not work very well:

  Imagine the following guard list: | PRIMARY_GUARD_1 | PRIMARY_GUARD_2 | PRIMARY_GUARD_3 | GUARD_1 | GUARD_2 | GUARD_3
  Imagine that PRIMARY_GUARD_1 and PRIMARY_GUARD_2 are marked as unreachable.

  a) Circuit A asks for guard. Receives PRIMARY_GUARD_3 and set state to USABLE_ON_COMPLETION.
  b) Circuit B asks for guard. Receives GUARD_1 (since PRIMARY_GUARD_3 is pending) and set state to USABLE_AFTER_RETRY.
  c) Circuit A fails to connect to PRIMARY_GUARD_3. All primary guards are unreachable, hence Circuit B is set to USABLE_ON_COMPLETION.
  d) Circuit A asks for guard. Receives GUARD_2 (since GUARD_1 is pending) and set state to USABLE_AFTER_RETRY.
  e) Circuit B connects to GUARD_1. Since its USABLE_ON_COMPLETION, we close all USABLE_AFTER_RETRY circuits including Circuit A.
  f) Circuit A asks for another guard. Receives GUARD_2 again? Or maybe GUARD_3? In any case, this is suboptimal.
